\documentclass[a4paper]{scrreprt}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[acronym]{glossaries}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{tablefootnote}
\usepackage{verbatim}
\usepackage{multirow}
\usepackage{subcaption}
\usepackage{floatrow}
\usepackage[binary-units=true]{siunitx}
\usepackage{wasysym}
\usepackage{physics}
\usepackage{hyperref}


\title{Development of an ultra-wide band indoor positioning system}
\author{Antoine Albertelli}
\titlehead{{\Large Ecole Polytechnique Fédérale de Lausanne}\\
    Laboratoire de Systèmes Robotique (LSRO)\\
    Supervisor: Daniel Burnier
}

\begin{document}

\newacronym{imu}{IMU}{Inertial Motion Unit}
\newacronym{dmp}{DMP}{Digital Motion Processor}
\newacronym{uwb}{UWB}{Ultra Wide Band}
\newacronym{ekf}{EKF}{Extended Kalman Filter}

\maketitle
\includepdf{abstract.pdf}
\tableofcontents

% TODO: Put each section in its own .tex
\chapter{Introduction}

\section{Requirements}

\section{State of the art}

%\begin{enumerate}
%    \item Sensor fusion using kalman for 9 axis IMUs is pretty common.
%        Usually done using quaternions to represent rotations.
%    \item Previous implementations of fusion with UWB focused on a applications of body positioning.
%\end{enumerate}

\chapter{Hardware}

The board used in this project contains the following elements:

\begin{itemize}
    \item An Invensense MPU9250 \gls{imu}.
    \item A Decawave DW1000 \gls{uwb} transceiver.
    \item An STM32F411 microcontroller.
    \item USB and CAN interfaces.
\end{itemize}

\section{Inertial Motion Unit}

The MPU9250 is a 9 axis \gls{imu} made by Invensense\footnote{\url{https://www.invensense.com}}.
It was chosen because it combines an accelerometer, a gyroscope and a magnetometer in an easy to use package.
It is connected to the main microcontroller through an SPI bus.

An interesting feature of this device is the \gls{dmp}.
It is a low power co-processor that can be used for a variety of purpose, including orientation estimation, in which it directly outputs a quaternion.
Unfortunately, we found out that this feature is poorly documented by the manufacturer, making it impossible to use without reverse engineering.
Additionally, the \gls{dmp} cannot use the magnetometer data.
Therefore, we decided not to use it but to implement our own sensor fusion on top of raw sensor information.

\section{UWB transceiver}
The board contains an \gls{uwb} transceiver which combines a physical interface and a MAC.
It has several features useful for our application:
\begin{enumerate}
    \item 802.15.4 compliant MAC which provides addressing features to avoid waking up on irrelevant traffic.
    \item High range, up to \SI{290}{\meter}.
    \item High accuracy timestamps for RX and TX of packets, allowing precision of up to \SI{10}{\centi\meter}.
    \item High data rate (up to \SI{6.8}{\mega\bit\per\second}).
    \end{enumerate}

\chapter{Positioning algorithm}

\section{Parametric vs.\  non-parametric filter}

Parametric filters are filter which take assumptions on the distribution of the state.
The most common assumption is that the distribution is Gaussian.
Non parametric filters, on the other hand, can represent any distribution, and most importantly multi modal ones.

If the problem can be solved using a parametric filter, it is better, as they are computationally less expensive.
Since we are running the code on a small device with little computing power, it is important to take this into account.

Early on this project we decided to use an \gls{ekf},  which is one of the most common state estimator.
Like the Kalman filter, which assumes that the distributions of the state and noise are gaussian.
However, it works on non-linear dynamics, by approximating the non linearities via a first order Taylor expansion.

While the \gls{ekf} is easy to implement and lightweight computationally, it makes the assumption that the noises is distributed according to a normal law.
We verified this property for the measurement noise (see Section~\ref{sec:range_result}), but could only assume it for the process noise.

\section{Simulation}

Testing the model's performance on the real system can be difficult.
First, implementing all the models in an embedded language like C or C++ is a tedious task.
Then, feeding the algorithm with recorded or generated measurements makes the results easier to compare and reproduce.
Therefore, we implemented a testing environment in Python.

Using Python allows to easily express high level mathematical objects.
For example, the Jacobian matrices are automatically computed using a symbolic math toolbox\footnote{Sympy: \url{http://www.sympy.org/}}, then converted to a numerical version.
Theoretically, it should even be possible to generate a C++ implementation from the symbolic representation, although that was not used in this project.
The framework allows us to create new \gls{ekf} models and test their performance in a matter of minutes.

\section{First model}

The goal of this model was to create the simplest thing that could possibly work.
It does not account for most issues, but was enough to start work on a simulator for the system.

To simplify the model, the following hypotheses are made:
\begin{enumerate}
    \item The robot moves in the 2D plane, i.e. its pose is described by $\left( x, y, \theta \right)$.
    \item The \gls{imu}'s internal motion processor already outputs $\theta$ (but it drifts).
    \item The \gls{imu} outputs the acceleration vector in body frame $\mathbf{a}^b$.
    \item The inertial frame is aligned with the world frame, i.e. the robot starts with $\theta=0$.
\end{enumerate}

The state contains the position and speed, in world frame:
\begin{equation}
    \mathbf{x} = \begin{pmatrix}x & y & \theta & \dot{x} & \dot{y}\end{pmatrix}^T
\end{equation}

\subsection{Motion model}

The first step is to transform the acceleration from body frame to world frame.

\begin{equation}
    \mathbf{a}^w = R(\theta) \mathbf{a}^b
\end{equation}

The state update equation, using the acceleration as control input

\begin{eqnarray}
    \dv{t} \mathbf{x} &=&
    \begin{pmatrix}
        \dot{x} & 
        \dot{y} &
        0 & % TODO: Maybe take it from acceleration ?
        \mathbf{a}^w_x &
        \mathbf{a}^w_y
    \end{pmatrix}^T \nonumber
    \\&=&
    \begin{pmatrix}
        \dot{x} \\
        \dot{y} \\
        0 \\  % TODO: Maybe take it from acceleration ?
        \cos(\theta) \mathbf{a}^B_x - \sin(\theta) \mathbf{a}^B_y \\
        \sin(\theta) \mathbf{a}^B_x + \cos(\theta) \mathbf{a}^B_y \\
    \end{pmatrix}
\end{eqnarray}

We can turn it into a discrete state update equation using the forward Euler method:

\begin{equation}
    \mathbf{x}_{t+1} = \mathbf{x}_t + \Delta_t \dv{t} \mathbf{x}
\end{equation}

\subsection{Measurement model}
In this model we have two different measurement functions.
The first one is given by the \gls{dmp} and is directly the heading $\theta$:
\begin{equation}
    h_{DMP}(\mathbf{x}) = \theta
\end{equation}

The second type of measurement is the distance to the UWB anchors.
It is actually a family of functions; each beacon defines a measurement function.
This function is the distance to the position of the beacon, called $\mathbf{b}$.

\begin{equation}
    h_b(\mathbf{x}) = \sqrt{\left(\mathbf{x}_x - \mathbf{b}_x\right)^2 + \left(\mathbf{x}_y - \mathbf{b}_y\right)^2}
\end{equation}

\subsection{Simulation results}
\begin{figure}[h!]
    \centering
    \begin{subfigure}[t]{0.4\textwidth}
        \includegraphics[width=\textwidth]{models/simple_model_trajectory.pdf}
        \caption{Trajectory}
    \end{subfigure}%
    ~
    \begin{subfigure}[t]{0.4\textwidth}
        \includegraphics[width=\textwidth]{models/simple_model_error.pdf}
        \caption{Position error}
    \end{subfigure}
    \caption{Simulation results using the simple model.
        The simulated robot moves at \SI{0.17}{\meter\per\second}.
        The \gls{uwb} ranges arrive at \SI{10}{\hertz}, while the accelerometer information was integrated at \SI{200}{\hertz}.
        \label{fig:simple_model}
    }
\end{figure}
\section{UWB only model}

This model was developped when I realized that the simple model had two important issues:

\begin{enumerate}
\item First, it supposed that we knew the rotation between the world frame and the earth magnetic frame, as the beacons' coordinates are in world frame, but the attitude of the robot is in earth magnetic frame.
\item The model had a lot of different variances to tune, making the tuning hard to do.
\end{enumerate}

This model removes those issues by relying only on the UWB radio ranging for measurement, and no prediction step.

\subsection{Model}

The state contains only the position of the robot.

\begin{equation*}
\mathbf{x} = \begin{pmatrix}x & y\end{pmatrix}^T
\end{equation*}


There is no information used for prediction, making the prediction function the identity:

\begin{equation}
\mathbf{x}_{k+1} = \mathbf{x}_{k}
\end{equation}

For the measurement, the UWB system gives us the distance $d$ to a beacon. The beacon's position $\mathbf{b}$ is known and assumed to be fixed.
Therefore the measurement model is given by Equation~\ref{eqn:uwb-only-measurement}.

\begin{equation}
h(\mathbf{x}, \mathbf{b}) = \sqrt{\left(x - b_x\right)^2 + \left(y - b_y\right)^2}
\label{eqn:uwb-only-measurement}
\end{equation}

\subsection{Tuning}

To compute the variance of the model, we estimate that the robot is moving at a constant speed of maximum $V_{max}$ between two measurements updates (which occurs at \(f_{UWB}\)).
Therefore, the maximum distance that a robot can do is given by Equation~\ref{eqn:travelled-distance}.

\begin{equation}
d = \frac{V_{max}}{f}
\label{eqn:travelled-distance}
\end{equation}

If we assume that \(d = 2 \sigma\), this means that our hypothesis is valid 97.5\% of the time, which is reasonable.
Therefore, the process variance can be estimated using Equation~\ref{eqn:variance}.
If we assume an update frequency of \SI{10}{\hertz} and a max speed of \SI{0.14}{\meter\per\second}, typical for a Thymio robot \cite{thymioweb}, we get a variance of $\sigma^2 = \SI{4.9e-5}{\meter\squared}$.

\begin{equation}
\sigma^2 = \left( \frac{V_{max}}{2 f} \right)^2
\label{eqn:variance}
\end{equation}


\subsection{Simulation results}

\begin{figure}[htpb]
    \centering
    \begin{subfigure}[t]{0.4\textwidth}
        \includegraphics[width=\textwidth]{models/uwb_only_trajectory.pdf}
        \caption{Trajectory}
    \end{subfigure}%
    ~
    \begin{subfigure}[t]{0.4\textwidth}
        \includegraphics[width=\textwidth]{models/uwb_only_error.pdf}
        \caption{Position error}
    \end{subfigure}
    \caption{
        Simulation results using only \gls{uwb} range information with 3 beacons.
        The simulated robot moves at \SI{0.17}{\meter\per\second}.
        The beacon distances were updated at \SI{10}{\hertz}.
        \label{fig:uwb_only}
    }
\end{figure}


\section{Differential measurement}

Out of curiosity, we also tried to implement a model where the robot would embed two \gls{uwb} modules separated by a known distance.
This should allow for a better precision, as well as measuring the heading of the robot.
We made the following assumptions:

\begin{enumerate}
    \item Robot moves in the 2D plane
    \item Gyro in the yaw axis
    \item  Gyroscope has constant bias ($b_\omega$) and random noise.
    \item \gls{uwb} receivers are separated by a fixed distance $d$.
\end{enumerate}

The state vector of the robot contains the position, speed and heading.
It also contains a constant term for the gyro bias, used to model the noise on the bias.


\begin{equation}
\mathbf{x} = \begin{pmatrix} x & y & \dot{x} & \dot{y} & \theta & b_{\omega} \end{pmatrix}^T
\end{equation}

\subsection{Model}

The prediction step uses outputs of the accelerometer (in body frame) and the angular rate as control inputs:

\begin{equation}
\mathbf{u} = \begin{pmatrix}
    a_x\\
    a_y\\
    \omega
\end{pmatrix}
\end{equation}

The differential equation governing the state evolution is therefore:

\begin{equation}
\mathbf{\dot{x}} = \begin{pmatrix}
\dot{x}\\
\dot{y}\\
\cos(\theta) a_x - \sin(\theta) a_y \\
\sin(\theta) a_x + \cos(\theta) a_y \\
\omega - b_{\omega}\\
0
\end{pmatrix}
\end{equation}

Using forward Euler integration we get:

\begin{equation}
\mathbf{x}_{k+1} = \mathbf{x}_{k} + \Delta_t \mathbf{\dot{x}} = \mathbf{g}\left(\mathbf{x}_{k}, \mathbf{u}_k\right)
\end{equation}

For the measurement step, the UWB system gives us the distance $d$ to a beacon.
The beacon's position $\mathbf{b}$ is known and assumed to be fixed.

We first compute the position of each UWB receiver. Receiver $n$ is assumed to be at position $\mathbf{x}_{UWB,n}^R$ in robot frame.

\begin{equation}
\mathbf{x}_{UWB,n}^W = \mathbf{x}_{robot}^W + \begin{pmatrix}
\cos \theta & - \sin \theta \\
\sin \theta & \cos \theta
\end{pmatrix} \mathbf{x}_{UWB,n}^R
\end{equation}

Then the measurement model is:

\begin{equation}
h_n(\mathbf{x}, \mathbf{b}) = \sqrt{(x_{UWB,n}^W - b_x)^2 + (y_{UWB,n}^W - b_y)^2}
\end{equation}

\subsection{Simulation results}
TODO


\section{Attitude estimation}

\chapter{Implementation}

\section{UWB beacons protocol}

\subsection{Design principles}

\begin{enumerate}
    \item The protocol should require as little state as possible to be stored on the participating beacons.
        State synchronisation between several systems is a common source of error and bugs.
    \item We want to maximize the measurement frequency, which means we should have a measurement simple with as little packets as possible.
    \item To avoid waking up the microcontroller, the MAC layer integrated in the \gls{uwb} module must be leveraged as much as possible.
    \item The same radio link used for range measurement will also be used as a general purpose link to transmit data between nodes.
\end{enumerate}

\subsection{Time measurement}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/ranging_protocol.png}
    \label{fig:ranging_protocol}
    \caption[Ranging protocol]{Messages in a time measurement interaction. Source:~\cite{dw1000manual}}
\end{figure}

The time measurement protocol is composed of a sequence of 3 messages.
To initiate a measurement sequence, an anchor broadcasts a measurement advertisement message to the broadcast address (0xFFFF).
Tags may respond with a measurement reply message.
Finally, the anchor sends a measurement finalization message and the tag computes the ranging solution:

\begin{equation}
T_{prop} = \frac{T_{round,1} \cdot T_{round,2} - T_{reply,1} \cdot T_{reply,2}}{T_{round,1} + T_{round,2} + T_{reply,1} + T_{reply,2}}
\label{eqn:ranging}
\end{equation}

The timing information is then converted to a distance by multiplying by the speed of light ($c$).

This 3-way ranging scheme works because transceivers can be programmed to send a frame at a given time.
Therefore, $T_{reply,2}$ can be included in the final message.

Some random implementations notes:

\begin{enumerate}
    \item Use 802.15.4 MAC to enable hardware filtering.
    \item Sequence number field will be hacked to store packet type in it instead.
    \item All numbers in payload are sent in network byte order (most significant byte first).
    \item All timestamps in messages are in DW1000 units and without a shared reference.
\end{enumerate}

\paragraph{Measurement advertisement}
A measurement advertisement message has a sequence number of 0.
It is sent by an anchor to the broadcast address (0xFFFF).
It only contains the TX timestamp as a 40 bit unsigned integer ($T_{tx,1}$).

\paragraph{Measurement reply}
A measurement reply message has a sequence number of 1.
It is sent by a tag and contains the timestamps of all events so far ($T_{tx,1}$, $T_{rx,1}$ and $T_{tx,2}$)

\paragraph{Measurement finalization}
Finally, the measurement finalization has a sequence number of 2.
It is sent by the anchor and contains the content of the previous message plus the new timestamps ($T_{rx,2}$, $T_{tx,3}$).

Once the tag received the last message, it can compute the ranging solution using Equation~\ref{eqn:ranging} with the following informations:
\begin{eqnarray*}
    T_{round,1} &=& T_{tx,1} - T_{rx,2} \\
    T_{reply,1} &=& T_{rx,1} - T_{tx,2} \\
    T_{round,2} &=& T_{tx,2} - T_{rx,3} \\
    T_{reply,2} &=& T_{rx,2} - T_{tx,3} 
\end{eqnarray*}



\subsection{Antenna delay calibration}
In order to obtain correct range readings, we should take in account the delay created by antenna transmission.
This delay should be calibrated as it will be different for each design \cite{dw1000manual}.
To do it, we simply measured the distance reported by the modules over a known range (averaged on N samples).
The antenna delay ($\Delta_T$) can then be computed by equation~\ref{eqn:delay-calibration}.

\begin{equation}
    \Delta_T = \frac{d_{measured} - d_{real}}{2\cdot c}
    \label{eqn:delay-calibration}
\end{equation}

On our system, this value was found to be about \textbf{TODO}.

\chapter{Results}

\section{Range measurement}
\label{sec:range_result}

% TODO test precision and recall

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{experiments/range_noise.png}
    \caption{Distribution of the range measured by the \gls{uwb} module in the optimal orientation.
        The corresponding gaussian fit is shown.
        We see that the error is pretty much normally distributed.
    }
    \label{fig:range_noise}
\end{figure}

% TODO: Impact of antenna orientation
% TODO: Impact of preamble length

\chapter{Future work}
\appendix
\chapter{Hardware schematic}

The following schematic is the one of the board used during this project.
However, several flaws were discovered and should be corrected before a new batch is produced.

\begin{itemize}
    \item There is currently now way to use the USB bootloader built in the microcontroller.
        This makes updating the board's firmware harder, as it requires a specialized debug adapter.
        Adding a button on pin BOOT0 would allow the user to enter bootloading mode as well as serving as a general purpose button.
    \item The reset pin of the \gls{uwb} module is connected to a pin used by the USB module of the microcontroller.
        Although one should be able to disable this pin by software, we could not make it work and had to cut a connection on the board.
\end{itemize}

All design documents and related issues can be found on the board's Github repository\footnote{\url{https://github.com/cvra/uwb-beacon-board/}}.


\includepdf[landscape=true]{figures/board_schematic.pdf}

\chapter{User manual}


\clearpage
\nocite{*} % tells bibtex to include everything
\bibliographystyle{ieeetr}
\bibliography{report}

\end{document}
